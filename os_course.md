# 操作系统

## 第1章 导论

### 操作系统的定义

操作系统是一直运行在计算机上的程序，通常称为内核（kernel），除了内核，还存在系统程序和应用程序。

### 计算机系统的运行

当计算机电源打开时，引导程序（Bootloader）一般位于计算机的固件，例如ROM和EEPROM中。他初始化各个组件，从CPU寄存器到内存，最后把操作系统内核加载到内存。一旦内核加载到内存并执行，他就开始为系统与用户提供服务。

### I/O结构

I/O中断适合移动少量数据，对于大量数据的移动，例如磁盘，应该使用直接内存访问（DMA），设备控制器可以再本地缓冲和内存直接传送整块数据，而无需CPU的干预，每块只产生一个中断，来通知设备驱动程序的操作已经完成。

### 多处理器系统

多处理器系统有两种类型：

- 非对称处理：一个主处理器负责调度从处理器
- 对称多处理（SMP）：所有处理器对等，共同参与操作系统的所有任务。

### 操作系统的结构

操作系统具有多道程序设计的能力。单个用户通常具有多个运行程序。**多道程序设计**通过安排作业使CPU始终忙碌，提高了CPU的利用率。作业首先保存在磁盘的作业池上，操作系统会选择一个子集，每次进行执行。CPU空闲时就会切换到另一个作业。

**分时系统**或**多任务**是多道程序设计的自然延伸，CPU不停地切换任务。分时系统要求计算机是可交互的，便于用户和系统直接通信

### 操作系统的执行

陷阱（trap）或异常（exception）是一种软件生成的中断，或源于出错（如除数为0或者无效内存访问）指异常，或源于用户程序的特定请求指陷阱。

#### 双重模式与多重模式

至少需要：用户模式和内核模式。一旦有陷阱或中断，硬件会从用户模式切换到内核模式。

用于保护可能损害机器的指令（特权指令），不能在用户模式下执行。

#### 定时器

可以用于防止用户运行时间过长。

### 实时操作系统

当处理器执行或数据流动具有严格的时间要求时，要使用实时系统。实时系统具有明确的、固定的时间约束，处理必须在固定时间约束内完成，否则系统你就会出错。与此相对的，分时系统只要相应快，而批处理系统则没有任何的时间约束。

## 第2章 操作系统结构

### 系统调用

通常，应用程序开发人员根据应用编程接口（API）来设计程序

### 操作系统的设计与实现

一个重要原则是策略与机制的分离，机制决定如何做，而策略决定做什么。例如定时器是一种保护CPU的机制，但为某个特定用户应将定时器设置成多长时间，是一个策略问题。
对于灵活性，策略与机制的分离至关重要。策略可随时间或地点而改变。在最坏情况下，每次策略的改变都可能需要改变底层机制。

### 操作系统的结构

简单结构，分层方法，微内核等。

微内核，在内核模式下仅处理进程间通信，内存管理，CPU调度。微内核可以在应用程序和运行在用户空间中的各种服务提供通信。微内核的优点之一是便于扩展操作系统，新服务可以在用户空间内增加而不需要改变内核。

## 第3章 进程管理

### 进程概念

进程是动态的、独立的、并发的。

进程是执行的程序。程序只是被动实体，进程是活动实体。包括文本段，程序计数器，堆栈，数据段，堆等。

#### 进程状态

- 新的：程序正在创建
- 运行：指令正在执行
- 等待：进程等待某个时间，例如I/O
- 就绪：进程等待分配处理器
- 终止：进程完成

一次只有一个进程处于运行状态，可能会有多个进程处于就绪或等待状态。

运行状态接收中断进入就绪状态；运行等待I/O进入等待状态，I/O完成进入就绪状态由调度器调度进入运行状态。

#### 进程控制块

又称任务控制块（PCB/TCB）往往包含进程的多种信息：

- 进程状态
- 程序计数器
- CPU寄存器
- CPU调度信息
- 内存管理信息
- 记账信息：CPU时间，实际使用时间，进程数等。
- I/O状态信息：分配给该进程的I/O设备列表、打开文件表等。

### 进程调度

进程调度器选择一个可用进程到CPU上执行。

#### 调度程序

通常对于批处理系统，提交的进程多余可执行的，进程会保存在缓冲池中。**长期调度程序**或作业调度程序从该池中选择进程加载到内存执行。**短期调度程序**或CPU调度程序从就绪队列中选择进程，分配CPU。

这两种调度程序的区别是执行频率。**短期调度程序**必须经常为CPU选择新的进程。进程可能执行几毫秒就请求I/O。**长期调度程序**执行并不频繁，它控制多道程序程度（内存中的进程数量）。只有在进程离开系统时，才需要长期调度程序。

重要的是，长期调度程序要认真选择。大多数进程可分为I/O主或者CPU主。I/O密集型会更多执行I/O，CPU密集型会更多使用CPU。**长期调度程序**需要将这两种进程进行合理的组合，使得CPU和I/O平衡，系统性能达到最佳。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        

有时候会使用中期调度程序来把进程移入或移除内存来改变多道程序程度。

#### 上下文切换

保存上下文，保存CPU状态，再上下文切换。

### 进程通信

进程间通信有两种基本类型：共享内存、消息传递。

#### 共享内存

生产者，消费者问题。需要一个缓冲区，这个缓冲区可分为无界缓冲区和有界缓冲区。

#### 消息传递

分为多种模式

- 直接通信：一个链路只与两个进程相关，每对进程之间仅有一个链路。如果使用寻址的非对称性，只需要发送者指定接收者，而接收者不需要指定发送者
- 间接通信：通过邮箱或端口来发送和接收消息。一个邮箱用一个整数值来标识，可以往邮箱内存放、读取、删除消息。

#### 同步

进程通信通过调用源语send()和receive()来进行。但要考虑是否同步，是否阻塞。

#### 缓存

通信进程交换的消息总是驻留在临时队列中。实现队列有三种方法：

- 零容量：队列大小为0
- 有限容量：如果满了，发送者应阻塞。
- 无限容量：发送者从不阻塞。

## 第4章 多线程编程

### 概述

线程共享同一进程的**代码段**、**数据段**、**堆**和**其他操作资源**，拥有唯一的**线程ID**、**程序计数器**、**寄存器和栈**。

线程创建所需要的的内存和资源远小于进程创建。

### 多核编程

单核可以并发，但多核才能并行。

数据并行和任务并行：

- 数据：注重将数据分布于多核之中，在每个核执行相同的操作。
- 任务：把不同任务分配到多个核中。

### 多线程模型

可能存在多个用户线程和多个内核线程。

- 多对一：多个用户线程跑在一个内核线程上：并不能并行。
- 一对一：一个用户线程到一个内核线程：每创建一个用户线程就需要创建内核线程，会**影响性能**。
- 多对多：多个用户线程到相同数量或者更少数量的内核线程：即增加并发性，也不会在内核中创建过多的线程。
- 双层模型：多对多的一个变种，允许某个用户线程绑定到一个内核线程中。

#### 线程池

在进程开始时创建一定数量的线程，并加入到池中等待工作。他限制了任意时刻线程的最大值，如果池内没有可用线程，服务器会一直等待，而不是去尝试创建新的线程。

## 进程调度

### 概论

每当CPU空闲时，操作系统使用**短期调度程序或CPU调度程序**（同上文概念），从就绪队列中选择一个进程来执行。就绪队列的实现可以多种多样，不一定是FIFO。

#### 抢占调度

非抢占调度只会出现在**运行到结束**和**运行到阻塞（I/O请求）**的情况下。

在非抢占状态下，一旦某个进程分配到CPU，该进程就会一直使用CPU，直到终止或者切换到**等待**状态。

### 调度准则

为了比较调度算法的好坏，用以下特征来区分：

- CPU使用率
- 吞吐量：在一个时间单元内完成的进程数量
- 周转时间：从进程**提交**到进程完成的这段时间，包括了等待时间，在CPU和I/O中执行的时间。
- 等待时间：进程在就绪队列中**等待**所话的时间之和。
- 响应时间：从进程**提交**到以**第一次响应**的时间。

### 调度算法

#### 1.先到先服务FCFS

使用FIFO队列很容易实现，是非抢占的。会造成I/O密集型等待CPU密集型进程的情况，这又称之为**护航效应**。

#### 2.最短作业优先调度SJF

空闲时选择最短的作业，相同时间可以使用FCFS算法来处理，SJF可以是抢占的也可以是非抢占的，在所有算法中是**最优的**。

SJF算法常用于**长期调度**。SJF算法困难之处是如何知道下次CPU执行的长度，一般测量以前CPU长度的指数平均来拟合。

#### 3.优先级调度

优先调度可以是抢占的或者非抢占的，每次会执行最高优先级的进程或者抢占当前进程。

优先调度可能会造成**无限阻塞或饥饿**。通常使用**老化**来解决：逐渐增加等待时间很长进程的优先级。

#### 4.轮转调度RR

类似于FCFS，但是使用一个时间片来抢占进程。就绪队列作为循环队列。

进程过小于时间片的CPU执行。进程本身会释放CPU，接着处理下一个进程。否则会中断，进行进程切换。

RR的性能很大城区取决于时间片的大小。

#### 5.多级队列调度

讲就绪队列分为多个单独队列，每个队列可以使用自己不同的调度算法。每个队列与更低层次的队列相比都具有绝对的领先。

#### 6.多级反馈队列

允许进程在不同队列中迁移。如果一个进程使用过长的CPU时间，他会被放到更低优先级的队列，同时，等待过久的进程也会被移动到更高优先级的队列。这可以**阻止饥饿**的发生。例如如果一个进程不能在这一时间片内完成，它会被移动到下一个队列的尾部。

多级反馈是最通用的CPU调度算法，同时也是最复杂的算法。

### 多处理器调度

#### 方法

除了单处理器的情况，多处理器中让负载分配成为可能。

CPU调度方法分为：非对称多处理和堆成多处理（SMP）。

#### 处理器亲和性

大多数SMP系统都避免将一个进程移动到另一个处理器上，而是试图让它运行在同一个处理器上。

## 第6章 同步

多核系统中，要求不同核上作出的改变不会互相干扰。

### 临界区问题

临界区，不能有两个进程同时在一个临界区执行。

临界区问题的解决方案应满足以下三个条件：

- 互斥
- 进步（有空让进）：没有进程在临界区执行时，可以选择一个进程进入，并且这种选择不是无限推迟的。
- 有限等待：一个进程请求进入到进入临界区这个期间，其他进程进入该临界区的次数是有限的。

### Peterson解决方案

是一种基于软件的解决方案，使用两个共享的数据项：

```
int turn;
boolean flag[2];
```

turn表示哪个进程可以进入临界区，flag[i]表示哪个进程准备进入临界区。

伪代码如下：

```
do{
	flag[i]=true;
	turn=j;
	while(flag[j]&&turn==j)
	;
	//临界区
	flag[i]=false;
	//剩余区
}
while(true)
```

**现代计算机不能确保Peterson算法能正确运行。**

在乱序执行的机器上，可能会出现：

互斥将得不到满足。
因为进程i和j的执行不是原子的，所以会出现并行的情况：

进程i:turn=j;
进程j:turn=i;
进程j:flag[j]=true;此时j能进入临界区。
进程i:flag[i]=true;此时i也能进入临界区。
同样地，交换i，j次序，也会产生相似地情况。 

### 硬件同步

使用原子指令（不可中断的指令），常使用`test_and_set(bool *target)`和`compare_and_swap(int *value，int expect int new_value)`

### 互斥锁

一个进程在进入时应得到锁，退出时应释放锁。acquire()获取锁，函数release()释放锁，每个锁用一个布尔变量available来表示。

```
acquire(){
	while(!available)
	;
	available=false;
}
release(){
	available=true;
}

do {
	acquire();
	临界区
	acquire();
	剩余区
}
while(true)
```

互斥锁的缺点是他需要忙等。等待进入临界区的进程会循环地调用acquire()，这也被成为自旋锁。

自旋锁的优点是：不需要上下文的切换，当使用锁的时间较短时，可用。自旋锁多用于多处理器系统，一个线程在一个处理器上旋转，其他线程执行临界区。

### 信号量

信号量用整型变量s表示，比起互斥锁更加高级。

使用wait()和signal()来操作。

```
wait(s){
	while(s<=0)
	;
	s--;
}
signal(s){
	s++;
}
```

可以对信号量的实现做修改，使他不忙等而是阻塞自己。

```
wait(s){
	s--;
	if(s<0){
		add process to list;
		block()
	}
}
signal(s){
	s++;
	if(s<=0){
		remove porcess to list;
		wakeup();
	}
}
```

### 经典同步问题

有界缓冲问题，读者-作者问题，哲学家就餐问题

#### 有界缓冲问题

```
int mutex=1;
int empty=n;
int full=0;

生产者
do{
	wait(empty);
	wait(mutex);
	do_produce();
	signal(mutex);
	signal(full);
}
while(true)

消费者
do{
	wait(full);
	wait(mutex);
	do_assume();
	signal(mutex);
	signal(empty);
}
while(true)
```

#### 读者-作者问题

读者优先

```
seamphore rw_mutex=1;
seamphore mutex=1;
int read_count=0;
//作者
do{
	wait(rw_mutex);
	//写
	signal(rw_mutex);
}
while(true)

//读者
do{
	wait(mutex);	
	if(read_count==0)
		wait(rw_mutex);
	read_count++;
	signal(mutex);
	
	//reading
	
	wait(mutex)
	read_count--;
	if(read_count==0)
		signal(rw_mutex);
	signal(mutex);
}
while(true)
```

共同竞争

```
seamphore rw_mutex=1;
seamphore mutex=1;
seamphore w=1;
int read_count=0;
//作者
do{
	wait(w);
	wait(rw_mutex);
	//写
	signal(rw_mutex);
	signal(w);
}
while(true)

//读者
do{
	wait(w);
	wait(mutex);	
	if(read_count==0)
		wait(rw_mutex);
	read_count++;
	signal(mutex);
	signal(w);
	
	//reading
	
	wait(mutex)
	read_count--;
	if(read_count==0)
		signal(rw_mutex);
	signal(mutex);
}
while(true)
```

#### 哲学家就餐问题

限制人数

```
seamphore chopstick[5]={1};
int mutex=4;最多4个人同时拿起筷子
//第i个哲学家
do{
	wait(mutex);
	wait(shopstick[i]);
	wait(shopstick[(i+1)%5]);
	//eating
	signal(shopstick[i]);
	signal(shopstick[(i+1)%5]);
	signal(mutex);
	//thinking
}
while(true)
```

奇数先拿左侧，偶数拿右侧

```
chopstick[5]={1};
//第i个哲学家
do{
	if(i%2==1)
	{
		wait(shopstick[i]);
		wait(shopstick[(i+1)%5]);
	}
	else{
		wait(shopstick[(i+1)%5]);
		wait(shopstick[i]);
	}
	//eating
	signal(shopstick[i]);
	signal(shopstick[(i+1)%5]);
	
	//thinking
}
while(true)
```

#### 抽烟问题

```
seamphore offer0,offer1,offer2;
seamphore finish;
//商店老板
do{
	if(i==0)
		signal(offer0);
	else if (i==1)
		signal(offer1);
	else if(i==2)
		signal(offer2);
	wait(finish);
	i=(i+1)%3;
}while(true)
//第i个客人
do{
	wait(offeri);
	//smoking
	signal(finish);
}
while(true)
```

#### 过桥问题

桥能容纳1人，中间容纳2人

```
number=2;
mutex_n=1;
mutex_s=1;
//北岸
do{
	wait(number);
	wait(mutex_n);
	//reach middle
	signal(mutex_n);
	wait(mutex_s);
	//go
	signal(mutex_s);
	signal(number);
}
while(true)
//南岸
do{
	wait(number);
	wait(mutex_s);
	//reach middle
	signal(mutex_s);
	wait(mutex_n);
	//go
	signal(mutex_n);
	signal(number);
}
while(true)
```

#### 司机售票员问题

先关门，后开车；
先形势，后售票；
先停车，后开门；

仅需要保证同步，无互斥。

```
semaphore door=1;     //door=1开门， =0关门
semaphore stop=1；      //1=汽车停止
semaphore start=0;    //1=启动汽车

Driver（）{           //司机
    while(True){
    wait(door);
    //启动汽车；
    signal(start);
    //行驶
    //到站停车
    signal(stop)；
    }
} 

Busserver(){      //售票员
    while(True){
    //关门
    signal(door);
    wait(start);
    //售票
    wait(stop)；
    //开门
    }
}
```

#### 理发师问题

没人剪头，理发师会睡着，有人理发。若没有座位，直接离开。所以顾客不需要使用死循环。

```
semaphore customers=0; //customers表示等候理发师的顾客
semaphore barbers=0;  //barbars表示已经醒来的理发师
int waiting =0;     //等待人数
semaphore mutex=1;  //用于保护waiting的互斥访问
define MAX_CHAIR 5;
理发师进程：
do
{
    wait(customers) //检查是否有顾客
	wait(mutex);
	waiting--;
    signal(mutex);
    signal(barbers)  //理发师已醒来
    Cut_hair();
}
while(true)
顾客进程：
do{
	wait(mutex) 
	if(waiting<MAX_CHAIR)
	{
		waiting=waiting+1;
 	    signal(mutex);
 	    signal(customers);
	    wait(barbers); //检查是否有醒来的理发师
        Get_haircut();
    }
    else
		signal(mutex); //表示座位已经满了
}
```

## 第7章 死锁

 ### 死锁的特征

#### 必要条件

- 互斥：至少一个资源处于非共享模式。
- 占有并等待：一个进程应占有至少一个资源，并等待另一个资源，且这个资源被其他进程占有。
- 非抢占：资源不能被抢占。
- 循环等待

这四个条件并不完全独立。

#### 资源分配图

节点V可分为进程P和资源R。

- 有向边P->R：申请边
- 有向边R->P：分配边

如果资源分配图没有环，系统就不处于死锁状态。如果存在环，系统也不一定处于死锁状态。

无环->不死锁。

### 死锁处理方案

- 预防或避免死锁
- 允许进入死锁，并检测修复
- 忽略这个问题

操作系统一般会忽略死锁问题，所以要由程序员自己处理死锁。

### 死锁预防

确保四个必要条件中至少一个不成立。

#### 互斥

通常不能通过否定互斥来预防死锁。

#### 占有并等待

- 协议1：每个进程在执行前申请并获得所有资源。
- 协议2：仅在没有资源时才可申请资源，即一个进程在申请更多资源之前，应该先释放已分配的所有资源。

缺点：资源利用率低，可能分配但很久都不使用。可能存在饥饿，一个进程可能为了需要资源而永久等待。

#### 无抢占

如果一个进程持有资源并申请一个不能被立刻分配的资源，那么当前进程的资源都可以被抢占。

这个协议常用于可以保存和恢复的资源，例如CPU寄存器和内存。

#### 循环等待

对所有**资源类型**进行排序，要求进程以递增的顺序来申请资源。进程需要一次性申请一种资源，并且要按照从小到大的顺序。

### 死锁避免

死锁预防会导致设备使用率低，吞吐率低。死锁避免算法决定如何申请资源。

#### 安全状态

如果系统能按一定顺序为每个进程分配资源，仍能避免死锁，则当前状态就是安全的，至少存在一个安全序列，系统才是安全的。相反，系统就是非安全的。死锁是非安全状态的子集。

#### 资源分配图算法

适用于每种资源类型只有一个实例的情况。

除了申请边和分配边，使用一种新的边称之为需求边，P->R，用虚线表示。当只有申请边变成分配变且不会有环存在时，才允许申请。

#### 银行家算法

在申请资源之前，系统应确定这些资源分配是否能保持安全状态。

银行家算法需要以下数据结构：n为进程数，m为资源种类

- available：表示每种资源的可用数量
- Max: n×m的矩阵，表示为每个进程的最大需求
- Allocate: n×m的矩阵，表示为已经分配的进程和对应资源数量
- Need: n×m的矩阵，表示为还需要的资源数。Need=Max-Allocate

##### 安全算法

判断系统是否处于安全状态

依次查找全部的进程，某个进程能分配所有资源并释放，就先分配并释放，知道所有进程都满足，或者有不满足的则当前不是安全状态。

##### 资源请求算法

如果当前进程需求的≤可用的，分配，否则使该进程等待。

### 死锁检测

如果不适用死锁避免和死锁预防，就要使用死锁检测

#### 如果只有一个实例

使用资源分配图的一个变形，称之为等待图。若P1等待P2释放资源，则存在边P1->P2。存在环时系统死锁。

#### 如果有多个实例

需要以下数据结构：n为进程数，m为资源种类

- available：表示每种资源的可用数量。
- Allocate: n×m的矩阵，表示为已经分配的进程和对应资源数量。
- Request: n×m的矩阵，表示为当前请求的资源数。

找到这样的进程使Request≤Available，Available+=Allocation，表示为如果**可以分配当前则假设今后也可以分配，系统分配并释放资源**。

对每个进程做这样的操作，如果存在进程未分配，则死锁。

与银行家算法很类似，区别在于银行家算法需要一次性分配全部其他资源，死锁检测可以分步分配。死锁检测是一种更加乐观的算法。所以死锁检测只能保证下一步不死锁，不能保证今后都不死锁（不保证一定存在安全序列）。

### 死锁恢复

进程终止：使用最小代价的规则。

#### 进程终止

可以终止死锁进程，或者依次终止进程知道死锁解除。

例如终止优先级低的、计算时间短的、批处理的。

#### 资源抢占

要注意选择牺牲进程，或者回滚到某个安全状态，防止一直抢占同一个进程造成的饥饿，所以要确保某一个进程要有限次地被牺牲。

## 第8章 内存管理

### 背景

在CPU和内存之间设计更快的内存，称之为高速缓存cache。为了保证每个进程有单独的地址空间，需要通过两个寄存器，基地址和界限地址寄存器，来表示合法访问的物理地址的起始和大小。只有操作系统的特权指令才能修改这两个寄存器。

#### 地址绑定

可以按照一下规则之一进行：

- 编译时：直接加载
- 加载时：生成可重定位代码
- 执行时

### 交换

内存不够时可以从备份存储和内存之间交换，这增加了系统的多道程序程度。

### 连续内存分配

内存分配最简单的方法：分区

内存不断地分配给进程，直到没有足够大的区域为止。此时操作系统可以等待，也可以跳过这个进程，继续扫描输入队列。

动态储存分配问题有多种解决方案，一般分为：首次适应、最优适应、最差适应。后两种需要扫描全部区域。性能方面首次适应和最优适应空间利用率差不多，但首次适应更快。

#### 碎片

动态存储分配会导致外部碎片。存储被分成了很多的小孔。通常按照大小相同的块来分配内存，这样会存在内部碎片，这部分内存不能使用。

外部碎片的解决问题之一是**紧缩**，即移动内存内容，合并成一整块，往往开销都很高。只有重定位是动态的，并且在运行时进行的，才能合并。

另一个解决方法是，不使用连续内存。

### 分段

虚拟地址由段组成，段包含了段名称和段内偏移。

#### 分段硬件

段表用于映射地址。段表的每个条目都有**段基地址和段界限**。虚拟地址的段号作为段表的索引，得到真正的物理地址再加上段偏移。

### 分页 

**分页可以避免外部碎片，但分段不行**。

分页讲物理地址分配大小相同的块（4KB)，成为帧；虚拟地址也分成相同大小的块，称为页。虚拟地址分为页码和页偏移，页码作为页表的索引，而页表保存了所在物理地址的基地址。

使用一个有效-无效位来判断是否这个页合法。

分页的另一个优点是可以共享代码。

#### 分页硬件

可以使用一组寄存器来实现页表，也可以放在内存中，仅需页表基地址寄存器。

访问一个字节需要两次内存访问，所以可以使用TLB来加快访问速度 。TLB由键和值构成，基本上没有性能负担。虚拟地址页号先去TLB访问，未命中才去页表中查询。

### 页表结构

#### 多级页表

将页表划分成多个索引，用前一个索引指向后一个页表的物理地址。

#### 哈希页表

虚拟地址索引通过哈希函数来索引哈希表。比较索引和哈希表中的字段，如果相等则取出物理地址，不相等则继续向链表后面比较。

## 第9章 虚拟内存管理

虚拟内存不要求程序一次性全部加载到物理内存中，这样的话程序就不再受物理地址的限制。

同时可以运行更多的程序，增加CPU的利用率。

### 请求调页

程序不需要一次性加载到内存，尽在需要时才加载，这被称为请求钓页。

试图访问不在内存中的页会造成缺页错误。处理这种错误的方法也很简单：

1. 判断访问是否无效，无效则终止进程。
2. 找到一个可用的空闲帧。
3. 讲刚刚的页面分配到帧。
4. 修改页表和内部表
5. 重启刚刚被中断的指令。

### 写时复制

使用fork()之后并不会立刻复制，而是等到修改页面时才进行复制。

### 页面置换

如果找不到空闲帧，则释放一个帧，把他的数据写到交换空间，并修改页表。再使用该空闲帧。

这需要两个页面传输，增加了缺页的错误处理时间，采用修改位或脏位来标记可以减少开销。如果写入内存的帧没有被修改，就不需要被写回置换空间，例如只读文件。

为了实现请求调页，要这季**帧分配**算法和**页面置换**算法。

#### FIFO页面置换

用FIFO队列来记录，性能差。

#### 最优页面置换OPT/MIN

置换最长时间不会使用的页面。难以实现，因为需要知道今后的页面使用情况（与SJF算法类似）

#### 最近最少使用算法LRU

LRU置换使用上次最长时间没有使用过的页。

LRU需要一些硬件辅助：

- 计数器：用来记录最后一次使用页的时间，但是需要搜索页表才能找到最后一次使用的页，
- 堆栈：每次使用页时就把他拿到栈顶，更新有点费时，但搜索很快。

但是除了TLB寄存器，没有其他硬件时，这两种**LRU算法都是不可行的**，因为太慢了。

#### 近似LRU页面置换

许多系统通过引用位来判断，最开始引用位清零，使用的时候置1，这也是一种LRU算法。

##### 额外引用位

可以使用多个引用位例如8位，每间隔一段时间（例如100ms）右移一位，只要比较数据大小就知道哪个页面更近使用。

##### 二次机会算法

是一种FIFO算法，扫描页表，如果是0则直接替换，如果是1则置0并跳过这个页面。一般使用循环队列来实现。

##### 增强型二次机会算法

用一个有序数对（引用位，修改位）来标记页面。分为以下四种情况：

- （0,0）：没有使用且没有修改，最佳选择。
- （0,1）：没有使用但有修改，置换时需要写回。
- （1,0）：有使用但没有修改，置换后可能又要用到该页。
- （1,1）：有使用且有修改，最差的选择。

### 帧分配

帧分配的数量与性能息息相关。如果帧分配的少，则缺页错误率增加，进程运行慢。

帧的最小数由架构决定，例如有些架构在寻址时会跨越2个页面，就会需要多个帧。

最大帧数由物理地址大小决定。

#### 分配算法

- 平均分配：帧总数除以进程数
- 比例分配：根据虚拟内存大小的比例来分配帧

比例分配还可以根据进程优先级的大小以及混合虚拟内存大小来调整。

#### 全局分配和局部分配

置换算法的不同

- 全局置换：允许牺牲任意帧
- 局部置换：只能牺牲自己定进程的帧

### 系统抖动

如果分配的帧小于计算机体系结构所需的最小帧，可能会造成全部页都在活动，但是又必须置换的情况。这样会一直产生调页，称之为抖动。

如果一个进程的调页时间大于执行时间，那么他就在抖动。

#### 系统抖动的原因

随着多道程序程度的增加，CPU的使用率先升高再减小，减小就是因为CPU在抖动，所以此时要降低多道程度。

为了定义一个进程所需的最小帧，引入工作集策略和**局部性模型**。

局部性模型指出：局部性是最近可能使用页面的一个集合。一个程序常由多个不同的重叠的局部组成。

需要保证覆盖全部进程的局部性帧之和>系统可用帧。

#### 工作集模型

使用参数Δ来表示工作集的大小，表示为检查Δ个页面的引用。如果Δ太小，会不能包含整个局部，Δ太大会包含多个局部。一旦确定了Δ，只需要为该进程分配大于其工作集的帧数就行。

#### 缺页错误频率

如果缺页错误率高，代表进程需要更多的帧，如果错误率太低，则代表进程分配的帧太多了。

缺页错误率随时间的示意图能看作工作集的移动。

### 分配内核内存

内核内存常不同于用户内存：

- 内核应保守地分配内存，以保证最小化浪费。
- 内核往往需要分配在连续物理内存中。

#### 伙伴系统

分配2的次幂大小的内存。内部碎片严重。

#### slab分配

每个slab由一个或多个连续的页面组成，每个cache有一个或多个slab组成，每个内核数据结构都有对应其大小的cache。

slab分配器的优点：

- 没有碎片
- 可以从cache中快速分配。

简单块列表（SLOB）用大中小来描述对象大小。

### 其他注意事项

#### 预调页面

同时调入所需的所有页面。

假设预调s个页面，被使用了比例为a。那么要比较s×a的成本与预调其他页s×(1-a)的成本。

#### I/O连锁与页面锁定

有些页面应该被锁定，比如I/O时，可以引入锁定为，锁定时不能被置换。

## 第10章 文件系统

### 概述

文件可以分为程序和数据文件。

数据文件可以是数字的、字符的、字符数字或二进制的。

 还可以按照结构分为文本文件、源文件、可执行文件等。

#### 文件属性

文件属性因操作系统而异，大致可分为：

- 名称
- 标识符：唯一的数字
- 类型
- 位置
- 尺寸
- 保护
- 时间、日期和用户标识

所有文件的信息保存在目录中，目录保存在外存上

#### 文件操作

6个基本文件操作：

- 创建文件
- 写文件
- 读文件
- 重新定位文件
- 删除文件
- 截断文件：删除内容但保留属性

在首次使用文件之前进行open()，有且仅有一个打开文件表。可以通过打开文件表索引文件，同时为每个文件关联一个打开计数，用于表示多少个进程打开了这个文件。

文件锁允许一个进程锁定文件，防止其他进程访问。

- 共享锁：类似于读者锁，可以多个进程获取
- 独占锁：一次只有一个进程能获得这样的锁

另外，操作系统提供强制或建议的方案。强制锁是操作系统强制完成的，建议锁允许其他进程访问，但因由开发人员获取锁和释放锁。

#### 文件类型

通常将文件类型作为文件名的一部分，但UNIX系统一般通过幻数来表示，操作系统也不依赖文件名中的文件类型。

文件可以分为以下类型：

- 可执行文件
- 目标文件
- 源代码文件
- 批处理文件
- 标记文件
- 文字处理文件
- 库文件
- 打印或可视化文件
- 档案文件（用于压缩）
- 多媒体文件

#### 文件结构

简单结构：

- 行
- 固定长度
- 可变长度

复杂结构：

- 格式化的文档
- 重定位文件

### 访问访问

#### 顺序访问

可以向前读写，或者向后倒回n个记录。

#### 直接访问

直接访问基于文件的磁盘模型。修改文件必须以包含块编号作为参数，例如read(n),但是可以保留顺序访问read_next()和write_next()。

用户提供的块号一般是相对块号，从0开始。

#### 其他索引方法

可以为大文件添加索引文件（保留在内存中），包含指针。

### 目录与磁盘结构

磁盘可以分区，分区可以使用自己的文件系统。分区也限制单个文件系统的大小。

存储设备可以组成RAID

#### 目录

目录可以视为符号表，文件名作为目录条目，目录保存了每个文件的**文件控制块**。目录和文件都驻留在磁盘上。每个分区都有自己的目录。分区也可以跨磁盘。

可操作目录：

- 搜索文件
- 创建文件
- 删除文件
- 遍历目录
- 重命名文件
- 遍历文件系统

#### 单级目录

必须拥有唯一的名称

#### 两级目录

为每个用户创建一个单独的目录，每个用户都有自己的用户文件目录，只要求单个用户文件目录内部名称是唯一的。可以通过路径名来访问其他用户的文件。

#### 树形目录

两级目录的推广。有一个根目录，每个文件都有唯一的路径名。可以使用绝对路径或相对路径。

#### 无环图目录

一个子目录可以位于文件系统的多个地方，只要是无环图。

问题：删除一个文件可能会导致悬垂指针

解决方案：

- 删除所有链接
- 保留文件直到它的所有索引都被删除
- **保留文件的引用计数**

#### 通用图目录

允许有环的存在

需要垃圾收集，确定文件已被完全删除。

### 文件共享

软连接（基于符号链的共享方式）：可以名称不同，但指向同一个索引指针节点。

### 保护

口令保护、加密保护、访问控制

- 口令放在系统内部：开销小，速度快，不安全
- 加密保护：保密性强，需要花费一定时间
- 访问控制：文件中加一个访问控制列表，表示哪个用户可以访问以及权限，灵活。

## 第11章 文件系统的实现

### 文件系统结构

内存和磁盘之前的I/O传输块，每个块具有一个或多个扇区。

### 分配方法

#### 连续分配

每个文件在吃盘上占有一组连续的块。

存在外部碎片的问题。

可以合并外部碎片，把所有文件复制到另一块区域，再复制回来，把孔填掉。

连续分配难以确定一个文件到底需要多少空间。

#### 链接分配

每个块保存下一个块的指针。目录中仅保存首个磁盘块的指针。

连接分配没有外部碎片。

访问文件慢，必须从头开始找。

通常把多个块定义成一个簇，按照簇来分配，这样指针占的比例就小了，但是增加了内部碎片。

如果指针损坏，可能会故障，一般使用双向链表或者存储名称和相对块号。

**磁盘分配表FAT**

每个**卷开头的磁盘**用于存储该表。在该表中，每个磁盘块都有一个条目，可以按照块号来索引。

FAT与链接分配相同，条目中包含文件首块的块号，然后这个块号又包含着下一块的索引，最后一块指向结束值。未使用用0表示。

如果不对FAT缓存，会很慢，因为磁头每次都要移到卷头位置。

#### 索引分配

把所有的指针放在一起，称之为索引块。

每个文件有一个索引块。

每个文件都有自己的索引块，标记了条目和地址。

索引分配没有外部碎片，支持直接访问。

索引块的大小：

- 链接方案：一个索引块通常为一个磁盘块。
- 多级索引：一级索引指向二级
- 组合方案：混合使用，小文件不需要单独的索引块，部分用于直接块，部分用于多级索引

### 空闲空间管理：

位图：一个位向量来记录，0代表分配，1代表空闲。

链表：空闲链表头指向第一个空闲块，空闲块又包含下一个的指针，遍历很慢。

组：在链表基础上，第一个空闲块存储n个空闲块的地址，就不需要逐级访问。

### 恢复

一致性检查：检测目录结构和磁盘的数据块，修复不一致的位置。

日志：所有元数据修改按照顺序写到日志，提交的事务完成时，就从日志中删去。

如果系统崩溃，日志文件可能包含多个事务，交易可以继续从指针处执行，以保证文件系统结构保持一致。

WAFL：将修改的数据写入新块，而不是修改原本的块。当所有写完时，指针直接指向新快而释放旧块的空间。如果旧块不删除，则视为快照。

## 第12章 大容量存储设备

### 磁盘

分为固态硬盘（SSD），和硬盘

定位时间可分为：寻道时间+旋转延迟。

平均I/O时间=平均访问时间+（转移量/传输速率）+控制器开销

SSD没有磁头，没有寻道时间和旋转时延。

### 磁盘调度

寻道时间是刺鼻移动到扇区柱面的时间，旋转延迟是磁盘旋转目标扇区到磁头下的额外时间，磁盘带宽是串数字姐总数除以总时间。

如何选择访问请求队列中的磁盘？

#### FCFS调度

先来先服务

#### SSTF调度

处理离当前磁头最近的柱面。

会导致饥饿。

#### SCAN调度

来回扫描，像电梯一样。

#### C-SCAN调度

循环扫描，但到达一端时立刻回到开头，回程中不作任何操作。

#### LOOK/C-LOOK调度

在SCAN和C-SCAN的基础上，不需要移动到顶端，只需要移动到最远的那个磁道。

### 坏块

使用扇区备用或者扇区转移，通知控制器使用备用块。磁盘控制器（磁盘设备内部的一个硬件部件）会维护一个坏块链表。

## 第13章 I/O系统

设备驱动程序为I/O子系统提供了统一的设备访问接口。

I/O端口通常由四个寄存器组成，即状态、控制、数据输入和数据传输出寄存器。

### 硬件

设备与计算机通信通过端口。

PCI中线常用与处理器和内存子系统链接，扩展总线链接相对较慢的设备，SCSI总线链接硬盘。
